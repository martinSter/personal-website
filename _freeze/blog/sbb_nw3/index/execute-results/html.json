{
  "hash": "7d1045c6786c739ea4aba0eb34f3c32d",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: \"SBB Network Analysis - Part 3\"\nauthor:\n  - name: Martin Sterchi\n    email: martin.sterchi@fhnw.ch\ndate: 2025-04-01\ncategories: [\"Networks\"]\nimage: sbb_hb.jpg\nformat:\n  html:\n    df-print: paged\n    toc: true\ngoogle-scholar: false\n---\n\n\n\n\nAfter [Part 1](../sbb_nw/index.qmd) and [Part 2](../sbb_nw2/index.qmd), where I demonstrated how to create different versions of static networks, I now want to show how to construct a temporal network representation of the Swiss railway network. If you've followed along with the first two parts of this series, the code here should be easy to understand.\n\nThe temporal network representation I develop here is based on the **space-of-changes** approach. In this representation, a *directed* edge connects each station to all subsequent stations for a given \"Fahrt.\" Instead of aggregating edges between the same pairs of stations, we retain all edges at different points in time, storing both the start time of each edge, $t$, and the time required to traverse it, $\\delta t$. This is just one possible way to represent temporal edges (see, for instance, the 2012 overview paper by [Petter Holme and Jari Saramäki](https://doi.org/10.1016/j.physrep.2012.03.001)).\n\nWith this temporal network model, finding **time-respecting paths** between any two nodes closely mirrors what the SBB (Swiss railway) app does when searching for the fastest connections between stations.\n\nBut let's start the practical part now.\n\n::: {#0ab787f4 .cell execution_count=1}\n``` {.python .cell-code}\nimport pandas as pd\nfrom collections import Counter, defaultdict\n\n# Check versions of libraries.\nprint(\"Pandas version:\", pd.__version__)\n\n# Make sure there is no limit on the number of columns shown.\npd.set_option('display.max_columns', None)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nPandas version: 2.1.4\n```\n:::\n:::\n\n\n### Temporal edgelist\n\nAs for the *space-of-changes* representation, we start by loading the already processed “Ist-Daten” from [Part 1](../sbb_nw/index.qmd) and transform all date-time elements into the right format. Also, we only need a few of the columns, so we reduce the dataframe drastically to only 4 columns.\n\n::: {#070d9c23 .cell execution_count=2}\n``` {.python .cell-code}\n# Load the processed IST-DATEN.\ndf = pd.read_csv('ist-daten.csv', sep=\";\", low_memory=False)\n\n# Convert BETRIEBSTAG to date format\ndf['BETRIEBSTAG'] = pd.to_datetime(df['BETRIEBSTAG'])\n\n# Convert ANKUNFTSZEIT, AN_PROGNOSE, ABFAHRTSZEIT, AB_PROGNOSE to datetime format\ndf['ANKUNFTSZEIT'] = pd.to_datetime(df['ANKUNFTSZEIT'])\ndf['AN_PROGNOSE'] = pd.to_datetime(df['AN_PROGNOSE'])\ndf['ABFAHRTSZEIT'] = pd.to_datetime(df['ABFAHRTSZEIT'])\ndf['AB_PROGNOSE'] = pd.to_datetime(df['AB_PROGNOSE'])\n\n# Reduce to relevant columns.\ndf = df[[\"FAHRT_BEZEICHNER\",\"STATION_NAME\",\"ANKUNFTSZEIT\",\"ABFAHRTSZEIT\"]]\n\n# Check the dataframe.\ndf.head()\n```\n\n::: {.cell-output .cell-output-display execution_count=2}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>FAHRT_BEZEICHNER</th>\n      <th>STATION_NAME</th>\n      <th>ANKUNFTSZEIT</th>\n      <th>ABFAHRTSZEIT</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>0</th>\n      <td>80:800631:17230:000</td>\n      <td>Basel Bad Bf</td>\n      <td>2025-03-05 04:59:00</td>\n      <td>NaT</td>\n    </tr>\n    <tr>\n      <th>1</th>\n      <td>80:800631:17233:000</td>\n      <td>Basel Bad Bf</td>\n      <td>NaT</td>\n      <td>2025-03-05 06:07:00</td>\n    </tr>\n    <tr>\n      <th>2</th>\n      <td>80:800631:17234:000</td>\n      <td>Basel Bad Bf</td>\n      <td>2025-03-05 05:56:00</td>\n      <td>NaT</td>\n    </tr>\n    <tr>\n      <th>3</th>\n      <td>80:800631:17235:000</td>\n      <td>Basel Bad Bf</td>\n      <td>NaT</td>\n      <td>2025-03-05 06:43:00</td>\n    </tr>\n    <tr>\n      <th>4</th>\n      <td>80:800631:17236:000</td>\n      <td>Basel Bad Bf</td>\n      <td>2025-03-05 06:31:00</td>\n      <td>NaT</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n```\n:::\n:::\n\n\nWe now use almost the same function as for the *space-of-changes* representation in order to extract the edges between any station and all its subsequent stations in a given \"Fahrt\".\n\nThe only difference is that we extract, as the third element of an edge, the start time measured in minutes since the start of the day (2025-03-05 00:00:00). So, a train that departs at one minute past midnight will have the start time 1, as the following code demonstrates:\n\n::: {#c3fbfe34 .cell execution_count=3}\n``` {.python .cell-code}\n(pd.to_datetime(\"2025-03-05 00:01:00\") - pd.to_datetime(\"2025-03-05 00:00:00\")).total_seconds() / 60\n```\n\n::: {.cell-output .cell-output-display execution_count=3}\n```\n1.0\n```\n:::\n:::\n\n\nHere now the function that we will use to iterate over the \"Fahrten\":\n\n::: {#e5c97b9e .cell execution_count=4}\n``` {.python .cell-code}\n# Function to compute (directed) edges according to spaces-of-changes principle.\ndef get_edges_in_groups(group):\n    # Empty list for results of a group.\n    results = []\n    # Loop over all rows in group.\n    for i in range(len(group)):\n        # Nested loop over all subsequent rows.\n        for j in range(i + 1, len(group)):\n            # Now, append edge to results list.\n            results.append((\n                group.iloc[i][\"STATION_NAME\"], # Station of origin\n                group.iloc[j][\"STATION_NAME\"], # Station of destination\n                # Time of departure in minutes since the day began.\n                (group.iloc[i][\"ABFAHRTSZEIT\"] - pd.to_datetime(\"2025-03-05 00:00:00\")).total_seconds() / 60,\n                # Duration in minutes.\n                (group.iloc[j]['ANKUNFTSZEIT'] - group.iloc[i]['ABFAHRTSZEIT']).total_seconds() / 60\n            ))\n    # Return list.\n    return results\n```\n:::\n\n\nThis function is applied as before for the *space-of-changes* representation:\n\n::: {#8390d595 .cell execution_count=5}\n``` {.python .cell-code}\n# Now apply that function group-wise.\nedges_series = df.groupby(\"FAHRT_BEZEICHNER\", group_keys=False).apply(get_edges_in_groups)\n```\n:::\n\n\nWe can check the same \"Fahrt\" between Yverdon-les-Bains and Ste-Croix again.\n\n::: {#0888d8b0 .cell execution_count=6}\n``` {.python .cell-code}\n# Let's check out one FAHRT.\nedges_series[\"85:97:9:000\"]\n```\n\n::: {.cell-output .cell-output-display execution_count=6}\n```\n[('Yverdon-les-Bains', 'Vuiteboeuf', 333.0, 10.0),\n ('Yverdon-les-Bains', 'Baulmes', 333.0, 14.0),\n ('Yverdon-les-Bains', 'Six-Fontaines', 333.0, 18.0),\n ('Yverdon-les-Bains', 'Ste-Croix', 333.0, 33.0),\n ('Vuiteboeuf', 'Baulmes', 343.0, 4.0),\n ('Vuiteboeuf', 'Six-Fontaines', 343.0, 8.0),\n ('Vuiteboeuf', 'Ste-Croix', 343.0, 23.0),\n ('Baulmes', 'Six-Fontaines', 347.0, 4.0),\n ('Baulmes', 'Ste-Croix', 347.0, 19.0),\n ('Six-Fontaines', 'Ste-Croix', 351.0, 15.0)]\n```\n:::\n:::\n\n\nThat train starts at 333 minutes past midnight (which is 05:33). The durations are the same as before in the *space-of-changes* representation.\n\nThe final step before getting the data ready for the export is to flatten all the edges that are currently organized in the form of a Pandas series of lists.\n\n::: {#477f5a6b .cell execution_count=7}\n``` {.python .cell-code}\n# Flatten the result into one edgelist.\nedgelist = [x for l in edges_series.values for x in l]\n\nprint(\"Number of edges:\", len(edgelist))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nNumber of edges: 1110766\n```\n:::\n:::\n\n\nThe *space-of-changes* representation code now aggregated duplicate edges. Crucially, this step is omitted here as we want to keep the temporal represenation of edges. Thus, our temporal representation of the network will have 1'110'766 edges.\n\nThe final steps are easy: we change the station names to their BPUIC numbers, we convert both the start time and the duration of an edge to integer values, and we export the dataframe as a CSV file.\n\n::: {#c887262c .cell execution_count=8}\n``` {.python .cell-code}\n# Load the nodelist.\nnodes = pd.read_csv(\"nodelist.csv\", sep = \";\")\n\n# Create a node dict with BPUIC as values\nnode_dict = dict(zip(nodes.STATION_NAME, nodes.BPUIC))\n```\n:::\n\n\n::: {#150010b0 .cell execution_count=9}\n``` {.python .cell-code}\n# Transform edge dict to nested list and replace all station names with their BPUIC\nedges = [[node_dict[e[0]], node_dict[e[1]], int(e[2]), int(e[3])] for e in edgelist]\n\n# Create a dataframe\nedges = pd.DataFrame(edges, columns = ['BPUIC1','BPUIC2','START','DURATION'])\n\n# Have a look\nedges.head()\n\n# Export edge list\n# edges.to_csv(\"edgelist_temporal.csv\", sep = ';', encoding = 'utf-8', index = False)\n```\n\n::: {.cell-output .cell-output-display execution_count=9}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>BPUIC1</th>\n      <th>BPUIC2</th>\n      <th>START</th>\n      <th>DURATION</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>0</th>\n      <td>8503000</td>\n      <td>8500010</td>\n      <td>1294</td>\n      <td>54</td>\n    </tr>\n    <tr>\n      <th>1</th>\n      <td>8503000</td>\n      <td>8500090</td>\n      <td>1294</td>\n      <td>105</td>\n    </tr>\n    <tr>\n      <th>2</th>\n      <td>8500010</td>\n      <td>8500090</td>\n      <td>1393</td>\n      <td>6</td>\n    </tr>\n    <tr>\n      <th>3</th>\n      <td>8500090</td>\n      <td>8500010</td>\n      <td>1813</td>\n      <td>7</td>\n    </tr>\n    <tr>\n      <th>4</th>\n      <td>8500090</td>\n      <td>8503000</td>\n      <td>1813</td>\n      <td>112</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n```\n:::\n:::\n\n\nYou can download the result here: <a href=\"edgelist_temporal.csv\" download>Temporal Edgelist (CSV)</a>.\n\n### References\n\nHolme, P., & Saramäki, J. (2012). Temporal networks. *Physics Reports*, 519(3), 97-125. <https://doi.org/10.1016/j.physrep.2012.03.001>\n\n*The title image has been created by Wikimedia user JoachimKohler-HB and is licensed under [Creative Commons](https://creativecommons.org/licenses/by-sa/4.0/deed.en).*\n\n",
    "supporting": [
      "index_files\\figure-html"
    ],
    "filters": [],
    "includes": {
      "include-in-header": [
        "<script src=\"https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js\" integrity=\"sha512-c3Nl8+7g4LMSTdrm621y7kf9v3SDPnhxLNhcjFJbKECVnmZHTdo+IRO05sNLTH/D3vA6u1X32ehoLC7WFVdheg==\" crossorigin=\"anonymous\"></script>\n<script src=\"https://cdnjs.cloudflare.com/ajax/libs/jquery/3.5.1/jquery.min.js\" integrity=\"sha512-bLT0Qm9VnAYZDflyKcBaQ2gg0hSYNQrJ8RilYldYQ1FxQYoCLtUjuuRuZo+fjqhx/qtq/1itJ0C2ejDxltZVFg==\" crossorigin=\"anonymous\" data-relocate-top=\"true\"></script>\n<script type=\"application/javascript\">define('jquery', [],function() {return window.jQuery;})</script>\n"
      ]
    }
  }
}